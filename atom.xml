<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[This is Shi Jie. Nice to meet you.]]></title>
  <link href="http://iamshijie.github.io/atom.xml" rel="self"/>
  <link href="http://iamshijie.github.io/"/>
  <updated>2015-01-25T00:42:30+08:00</updated>
  <id>http://iamshijie.github.io/</id>
  <author>
    <name><![CDATA[Shi Jie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Retro]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/22/retro/"/>
    <updated>2015-01-22T17:18:36+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/22/retro</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Consumer-Driven Contracts Test - Pact & Pacto]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/21/consumer-driven-contract-testing-pact-and-pacto/"/>
    <updated>2015-01-21T19:06:36+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/21/consumer-driven-contract-testing-pact-and-pacto</id>
    <content type="html"><![CDATA[<p>实施microservices<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (小、松耦合、多服务、多语言、自动部署、易扩展、易集成、分布式&hellip;)架构后，测试变成为了一个难题，如何在多语言、多系统、甚至异步与动态消息的情况下进行测试？如何在build(构建)中进行自动化测试？如何进行集成测试<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>？</p>

<p>很多人会想到一些名词/工具：stub, mock, fake, dummy, spy, <a href="WebMock">WebMock</a>, <a href="https://github.com/vcr/vcr">vcr</a>, <a href="http://www.thoughtworks.com/radar/tools/mountebank">mountebank</a>&hellip;类似名词有很多，这些工具的思路也都类似，即在服务提供方和服务消费者之间，模拟/拦截消费者的请求，伪造一个结果请求结果返回给消费者，就如Martin Fowler说的</p>

<blockquote><p>use to stub out parts of a system for testing</p></blockquote>

<p>他给这些名词一个通用的叫法： TestDouble</p>

<blockquote><p>Test Double is a generic term for any case where you replace a production object for testing purposes</p></blockquote>

<p>replace，替代。即在测试中，对真实的对象进行替代。</p>

<p>但是，这种方式非常有局限性：</p>

<ol>
<li><p>TestDouble最重要的使用场景之一就是，与一个外部服务(external service)进行交互。但是你使用的double是否真的精确地代表了外部服务？如果外部服务改变了，你的测试又会发生什么？</p>

<p> 一个解决办法是，在自己的测试中使用double，同时定期的运行另外一套测试集，调用真实的外部服务，来查看外部服务的返回，是否与double测试中的相同。在Martin Fowler的blog中，称之为<a href="http://martinfowler.com/bliki/IntegrationContractTest.html">Tntegration Contract Test</a>。</p>

<p> 是不是觉得很麻烦？即使这样，还是需要在一部分测试中真实地调用外部服务。在复杂的多服务系统中(如microservices)，这样做不仅很困难，而且成本非常高(也许你得为这些测试准备一套完整的环境)。</p></li>
<li><p>TestDouble更适用于测试金字塔中的底层测试。对于UI层面的模拟用户的测试、集成测试，尤其是集成的自动化测试该怎么办呢？在microservices这种架构下，又该怎么办呢？</p></li>
</ol>


<p><a href="http://thoughtworks.github.io/pacto/patterns/cdc/">Consumer-Driven Contracts</a> Test就应运而生。<a href="https://github.com/realestate-com-au/pact">Pact</a>和<a href="https://github.com/thoughtworks/pacto">Pacto</a>都是这种消费者驱动的契约测试的产物。</p>

<p>每个消费者在一个单独的契约中，描述对服务提供者的期望。服务提供方在自己的测试集中，对这些“期望”进行校验。服务提供方在做出任何改变的时候，只要能保证满足消费者不对其产生影响即可。一旦对任何消费者产生影响，在正式发布前就可以知晓，而且只需要与那些会产生的影响的消费者进行协商即可。</p>

<p>这里的Contracts分为三部分<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>：</p>

<ol>
<li><p>提供者契约（Provider contracts）——提供者契约是我们最为熟悉的一种的服务契约，参考 WSDL+XML Schema+WS-Policy。顾名思义，提供者契约是以提供者为中心的。提供者规定了它要提供什么；然后，各消费者便将自己绑定到这个一成不变的契约上。不论消费者实际需要多少功能，消费者接受了提供者契约，就将自己与该提供者的全体功能耦合起来了。</p></li>
<li><p>消费者契约（Consumer contracts）——另一方面，消费者契约是对一个消费者的需求更为精确的描述。消费者契约描述了，在一次具体交互场合下，提供者功能中消费者需要的特定部分。消费者契约可被用来标注一个现有的提供者契约，另外消费者契约也有助于发现一个现今尚未规定的提供者契约。</p></li>
<li><p>消费者驱动的契约（Consumer-driven contracts）——消费者驱动的契约描述的是服务提供者向其所有当前消费者承诺遵守的约束。一旦各消费者把自己的具体期望告知提供者，消费者驱动的契约就被创建了。在提供者方面创建的约束，确定了一个消费者驱动的契约。若提供者接受了一个消费者驱动的契约，那么它只需保证已有约束仍能得到满足，即可自行改进与修改其服务。</p></li>
</ol>


<p>现在我们看看<a href="https://github.com/realestate-com-au/pact">Pact</a>和<a href="https://github.com/thoughtworks/pacto">Pacto</a>这两个测试框架是如何实现的。</p>

<h2>Pact</h2>

<p>Pact为服务消费者提供了API，用来定义消费者对服务提供方的http请求、以及期望的http响应。这些期望被用在消费者的spec测试中，来mock服务提供方。所有的交互都会被记录下，然后在服务提供方的spec测试中回放，来确保服务提供方确实提供了消费者所期望的响应。</p>

<p>这使得对于一个集成场景，契约的两方都可以快速、独立地进行单元测试。</p>

<p>工作原理<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> ：</p>

<p><img src="http://iamshijie.github.io/images/pact-step1.png" alt="pact-step1.png" /></p>

<p><img src="http://iamshijie.github.io/images/pact-step2.png" alt="pact-step2.png" /></p>

<p>Pact以gem的形式提供，gem地址：<a href="https://rubygems.org/gems/pact">https://rubygems.org/gems/pact</a></p>

<p>使用方法：<a href="https://github.com/realestate-com-au/pact#installation">https://github.com/realestate-com-au/pact#installation</a></p>

<p>一些最佳实践：<a href="https://github.com/realestate-com-au/pact/wiki/Best-practices">Pact-best-practices</a></p>

<h2>Pacto</h2>

<p>Pacto包含两部分，request clause和response clause。</p>

<p>Request clause定义了消费者发送给服务提供方的请求中必须包含的信息，这些信息将被用于一个渲染service。通常包含了http头、需要的参数、以及请求体（json形式）。</p>

<p>Response clause定义了服务提供方需要返回给消费者的信息，从而成功完成一次事务。通常包含请求头和请求体（json形式）。</p>

<p>通常通过产生、校验、服务打桩三部分。</p>

<p>使用方法：<a href="https://github.com/thoughtworks/pacto#usage">https://github.com/thoughtworks/pacto#usage</a>或者这里<a href="http://thoughtworks.github.io/pacto/usage/">http://thoughtworks.github.io/pacto/usage/</a></p>

<h2>区别：</h2>

<ol>
<li><p>Pacto仅支持json服务，原生支持Ruby，对于非Ruby项目，提供了<a href="https://github.com/thoughtworks/pacto#pacto-server-non-ruby-usage">Pacto Server</a>。</p>

<p> Pact支持Ruby, JVM(<a href="https://github.com/DiUS/pact-jvm">pact-jvm</a>), .net的消费者，Ruby mock server使用了Javascript进行包装。对于非ruby的服务提供方，Pact提供了<a href="https://github.com/bethesque/pact-provider-proxy">Pact Provider Proxy</a></p></li>
<li><p>Pacto不支持多状态码验证（如200、201）。Pact允许在服务提供者不同状态下，生成同样的请求，允许在同样的endpoint上测试不同的http响应码，或者在不同状态下测试相同的资源。</p></li>
<li><p>Pacto通过录制与现有服务的交互，可以录制契约。不用手工编写，使得契约非常容易创建。</p></li>
<li><p>Pacto一旦录制完成，契约就是静态的，既可以校验服务消费者，也可以校验服务提供方。</p>

<p> Pact的契约是动态生成的中间产物，更容易维护<a href="https://github.com/realestate-com-au/pact/wiki/FAQ#why-are-the-pacts-generated-and-not-static">why?</a>。</p></li>
<li><p>Pact支持正则表达匹配。</p></li>
<li><p>Pact有<a href="https://github.com/bethesque/pact_broker">Pact Broker</a>，提供了自动生成的文档、网络图，使得在产品环境和最新版本（消费者和提供者）间进行交叉测试成为可能，从而将消费者和提供者的发布循环解耦。</p></li>
</ol>


<p>总结：</p>

<ol>
<li><p>契约录制功能，使得当需要对一个现有第三方服务打桩的时候，Pacto成了更好的选择。在这种情况下，服务提供方状态的缺失、正则匹配可能无关紧要，因为你不可能在服务方创建一套数据，而不使用当前测试的接口。</p></li>
<li><p>对于服务提供方不还不存在的新项目来说，Pact可能更好，因为消费者的功能可以驱动出服务提供方的需求。</p></li>
</ol>


<p>参考资料：</p>

<ol>
<li><p><a href="http://www.slideshare.net/catosplace/lightening-talk-agile-auckland-pact-consumerdriven-contract-testing-integrated-tests-are-a-scam">Lightening Talk: Auckland Continuous Delivery Meetup [Sept 2014] - Pact: Consumer-Driven Contract Testing (Integrated Tests Are A Scam)</a></p></li>
<li><p><a href="http://techblog.realestate.com.au/testing-interactions-with-web-services-without-integration-tests-in-ruby/">realestate.com.au:http://techblog.realestate.com.au/testing-interactions-with-web-services-without-integration-tests-in-ruby/</a></p></li>
<li><p>微服务测试</p>

<p> <a href="http://martinfowler.com/articles/microservice-testing/#agenda"><img src="http://iamshijie.github.io/images/microservice-testing-summary.png" alt="microservice-testing-summary.png" /></a></p></li>
<li><p><a href="https://github.com/realestate-com-au/pact/wiki/FAQ#how-does-pact-differ-from-pacto">Pact and Pacto</a></p></li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>关于Microservices,参阅<a href="http://www.thoughtworks.com/radar/techniques/microservices">ThoughtWorks技术雷达</a>和<a href="http://martinfowler.com/articles/microservices.html">Martin Fowler的blog</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Martin Flower的<a href="http://martinfowler.com/articles/microservice-testing/#agenda">微服务测试</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>这三种契约的描述，摘自InfoQ的文章<a href="http://www.infoq.com/cn/articles/consumer-driven-contracts">用消费者驱动的契约进行面向服务开发</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>这两张图片来自<a href="http://dius.com.au/2014/05/19/simplifying-micro-service-testing-with-pacts/">Simplifying Micro-Service testing with Pacts</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用octopress创建个人博客]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/21/how-to-setup-blog-with-octopress/"/>
    <updated>2015-01-21T10:02:40+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/21/how-to-setup-blog-with-octopress</id>
    <content type="html"><![CDATA[<p>Refer to <a href="http://octopress.org/docs/setup">this link</a></p>

<p>开始之前的准备工作：安装Git、ruby、bundler。</p>

<h3>准备</h3>

<ol>
<li><p>下载octopress: <code>git clone git://github.com/imathis/octopress.git octopress</code></p></li>
<li><p>进入octopress目录，执行<code>rake install</code></p></li>
</ol>


<h3>创建部署</h3>

<ol>
<li><p>创建一个新的Github的空repo，并且命名为iamshijie.github.io</p></li>
<li><p>进入自己下载的octopress的目录并执行<code>rake setup_github_pages</code>。当提示输入repo地址时，输入上一步创建的git地址：<code>git@github.com:Shi-Jie/iamshijie.github.io.git</code></p></li>
<li><p>继续在octopress目录下执行<code>rake generate </code>。此时，打开<a href="http://iamshijie.github.io.git">http://iamshijie.github.io.git</a>就能看到blog原型。再执行<code>rake deploy</code></p></li>
<li><p>git提交。本别执行<code>git add .</code> 、<code>git commit -m 'your message'</code>、<code>git push origin source</code></p></li>
<li><p>修改个人blog的默认分支为source，而非master <a href="https://github.com/iamshijie/iamshijie.github.io/settings">git link</a></p></li>
</ol>


<h3>创建博客</h3>

<p>这部分可以参考之前在QA community的<a href="http://thoughtworks-china-qa.github.io/blog/2015/01/13/how-to-post-to-this-blog/">blog</a>。</p>

<ol>
<li><p>clone博客repo到本地：<code>git clone git@github.com:iamshijie/iamshijie.github.io.git</code></p>

<p> <strong>确保你的默认分支是source。即<code>git status</code>后看到的是</strong></p>

<pre><code class="`"> Shi-Jie:iamshijie.github.io shijie$ git status
 On branch source
 Your branch is up-to-date with 'origin/source'.
 nothing to commit, working directory clean
</code></pre></li>
<li><p>本地生成发布目录，执行<code>rake setup_github_pages</code>交互时输入<code>git@github.com:Shi-Jie/iamshijie.github.io.git</code></p></li>
<li><p>执行<code>rake install</code>。安装默认主题。</p></li>
<li><p>创建新post。在repo下执行<code>rake new_post["How to create blog with octopress"]</code></p></li>
<li><p>修改上一步生成的markdown文件，直接在默认生成的内容后进行添加编辑：</p>

<pre><code class="`"> ---
 layout: post
 title: "How to setup blog with octopress"
 date: 2015-01-21 09:16:24 +0800
 comments: true
 categories:
 ---
</code></pre></li>
<li><p>使用<code>rake preview</code>进行预览</p></li>
<li><p>确认无误后。使用<code>rake gen_deploy</code>发布的master。完成后，就可以在个人<a href="http://iamshijie.github.io">http://iamshijie.github.io</a>看到效果</p></li>
<li><p>将改动提交到source分支</p>

<pre><code class="`"> git add .
 git commit -m 'Post my first blog. - ShiJie'
 git push
</code></pre></li>
</ol>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[This is Shi Jie. Nice to meet you.]]></title>
  <link href="http://iamshijie.github.io/atom.xml" rel="self"/>
  <link href="http://iamshijie.github.io/"/>
  <updated>2015-01-31T09:55:34+08:00</updated>
  <id>http://iamshijie.github.io/</id>
  <author>
    <name><![CDATA[Shi Jie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用户研究与表达]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/25/user-researh-and-express/"/>
    <updated>2015-01-25T13:07:05+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/25/user-researh-and-express</id>
    <content type="html"><![CDATA[<h2>——用设计的方法看看市场</h2>

<h2>讲师项目及感悟</h2>

<p>A session from ThoughWorker 陈思(UX)</p>

<ol>
<li><p>global blue 国际蓝联</p></li>
<li><p>微软新输入设备设计：掀开盖头（扩展描述方法）</p>

<ul>
<li><p>unconvering feelings。设计输入设备，将问题转化为对人的描述——对产品特性、特点、定位。</p></li>
<li><p>unconvering dreams。想象他人问题的解决——产品的能力。跳出了自己，对别人的描述。</p></li>
</ul>
</li>
<li><p>可持续发展的旅行奢侈品设计</p>

<ul>
<li><p>对产品的需求访谈：主观 -> 客观，具体。</p></li>
<li><p>对产品的定义：唯一性。这个的产品是唯一能做XX的XX。</p></li>
</ul>
</li>
</ol>


<h2>练习：</h2>

<p>产品（航班纵横、非常准、12306），人物形象，人物故事，产品定义。（产品和人合二为一）</p>

<h2>用户研究的过程</h2>

<ol>
<li><p>确立主旨</p>

<ul>
<li><p>为什么要调研，需要针对哪些具体的方面（业务范畴，参与人员）</p></li>
<li><p>客户是干什么的</p></li>
<li><p>客户需要什么样的调研</p>

<ul>
<li><p>客户的自我分析：帮他创造出更好的形象，也可以让他们相信TW对他们有足够的了解，已经帮他们策划好了一条正确的金光大道</p></li>
<li><p>分析客户的用户：行业的熟知程度，足以支撑我们为他们营造的那条金光大道是可行可信的</p></li>
</ul>
</li>
</ul>
</li>
<li><p>搜集素材</p>

<ul>
<li><p>客户的自我分析：</p>

<ul>
<li><p>他们怎么表达自己？</p></li>
<li><p>他们怎么描述自己的服务？</p></li>
<li><p>他们怎么描述自己的竞争对手？</p></li>
</ul>
</li>
<li><p>分析客户的用户：</p>

<ul>
<li><p>分析客户的行为</p></li>
<li><p>什么时候会需要我们的客户，什么时候不需要，什么时候犹豫，得到客户的服务/产品后，怎么反馈和描述这个过程</p></li>
<li><p>分析客户与用户接触环节上的其他party</p></li>
<li><p>这些party对客户服务用户的过程有什么影响与反馈，他们是否有potential去促进这个过程</p></li>
</ul>
</li>
<li><p>分析竞争对手：</p>

<ul>
<li><p>竞争对手怎么表达自己？怎么描述自己的服务？怎样描述我们的客户？</p></li>
<li><p>我们的客户的核心价值在竞争对手中是否已经脱颖而出？</p></li>
</ul>
</li>
</ul>


<p> tips： social media。抱怨和缺点</p></li>
<li><p>下笔之前</p>

<ul>
<li><p>总结Search过程中的以下元素</p>

<ul>
<li><p>我被什么shock到了？抓住兴奋点：天哪！原来是这样！这个会shock你 就会惊艳你的客户</p></li>
<li><p>什么东西反复出现？也许是根基、新兴的方向、基础理论。不能忽略</p></li>
<li><p>什么东西可以合并</p></li>
<li><p>什么东西在我的脑海里，可是在第二步（search）中却从未被提到？这里也许包含有机会。</p></li>
</ul>
</li>
<li><p>面对竞争对手</p>

<ul>
<li><p>怎样以他为榜样</p></li>
<li><p>怎样站在他的肩膀上起跳</p></li>
</ul>
</li>
<li><p>方案雏形</p>

<p>  unconvering your feelings &amp; dreams</p></li>
</ul>
</li>
</ol>


<h2>Global blue</h2>

<ol>
<li><p>6~8个人就能发现80%的问题（定性的访谈，非定量）</p></li>
<li><p>报告结构</p>

<ul>
<li><p>The general picture</p></li>
<li><p>Customs Archetypes</p></li>
<li><p>Competitors Analysis</p></li>
<li><p>Insights &amp; Suggestions</p></li>
</ul>
</li>
</ol>


<h2>自我评价 Critical mind</h2>

<h2>Notes</h2>

<ol>
<li><p>用户研究，限定了用户（中国、俄罗斯）、行为（购物）、地点（境外）、内容（退税）</p></li>
<li><p>报告结构。完整、讲故事、相似句式。。。</p>

<ul>
<li><p>The general picture</p></li>
<li><p>Customs Archetypes</p></li>
<li><p>Competitors Analysis</p></li>
<li><p>Insights &amp; Suggestions</p></li>
</ul>
</li>
<li><p>报告tips</p>

<ul>
<li><p>风格一致：duplicate</p></li>
<li><p>图片：半透明边框、放大镜来、图片阴影</p></li>
<li><p>素材： <a href="http://www.zcool.com.cn/">http://www.zcool.com.cn/</a></p></li>
</ul>
</li>
<li><p>From Kai sang:</p>

<ul>
<li><p>发散、搜集资料。现成的研究报告</p></li>
<li><p>创建文件夹。对资料进行分类</p></li>
<li><p>形成观点。 * 有观点，找素材。 * 从素材找观点</p></li>
<li><p>粗略文档。从各处找有用材料进行填充、堆积。非精致的，有文档雏形即可</p></li>
<li><p>精致文档。素材修饰</p></li>
<li><p>雕刻文字</p></li>
<li><p>版式修正</p></li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Retro]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/22/retro/"/>
    <updated>2015-01-22T17:18:36+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/22/retro</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Consumer-Driven Contracts Test - Pact & Pacto]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/21/consumer-driven-contract-testing-pact-and-pacto/"/>
    <updated>2015-01-21T19:06:36+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/21/consumer-driven-contract-testing-pact-and-pacto</id>
    <content type="html"><![CDATA[<p>实施microservices<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (小、松耦合、多服务、多语言、自动部署、易扩展、易集成、分布式&hellip;)架构后，测试变成为了一个难题，如何在多语言、多系统、甚至异步与动态消息的情况下进行测试？如何在build(构建)中进行自动化测试？如何进行集成测试<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>？</p>

<p>很多人会想到一些名词/工具：stub, mock, fake, dummy, spy, <a href="WebMock">WebMock</a>, <a href="https://github.com/vcr/vcr">vcr</a>, <a href="http://www.thoughtworks.com/radar/tools/mountebank">mountebank</a>&hellip;类似名词有很多，这些工具的思路也都类似，即在服务提供方和服务消费者之间，模拟/拦截消费者的请求，伪造一个结果请求结果返回给消费者，就如Martin Fowler说的</p>

<blockquote><p>use to stub out parts of a system for testing</p></blockquote>

<p>他给这些名词一个通用的叫法： TestDouble</p>

<blockquote><p>Test Double is a generic term for any case where you replace a production object for testing purposes</p></blockquote>

<p>replace，替代。即在测试中，对真实的对象进行替代。</p>

<p>但是，这种方式非常有局限性：</p>

<ol>
<li><p>TestDouble最重要的使用场景之一就是，与一个外部服务(external service)进行交互。但是你使用的double是否真的精确地代表了外部服务？如果外部服务改变了，你的测试又会发生什么？</p>

<p> 一个解决办法是，在自己的测试中使用double，同时定期的运行另外一套测试集，调用真实的外部服务，来查看外部服务的返回，是否与double测试中的相同。在Martin Fowler的blog中，称之为<a href="http://martinfowler.com/bliki/IntegrationContractTest.html">Tntegration Contract Test</a>。</p>

<p> 是不是觉得很麻烦？即使这样，还是需要在一部分测试中真实地调用外部服务。在复杂的多服务系统中(如microservices)，这样做不仅很困难，而且成本非常高(也许你得为这些测试准备一套完整的环境)。</p></li>
<li><p>TestDouble更适用于测试金字塔中的底层测试。对于UI层面的模拟用户的测试、集成测试，尤其是集成的自动化测试该怎么办呢？在microservices这种架构下，又该怎么办呢？</p></li>
</ol>


<p><a href="http://thoughtworks.github.io/pacto/patterns/cdc/">Consumer-Driven Contracts</a> Test就应运而生。<a href="https://github.com/realestate-com-au/pact">Pact</a>和<a href="https://github.com/thoughtworks/pacto">Pacto</a>都是这种消费者驱动的契约测试的产物。</p>

<p>每个消费者在一个单独的契约中，描述对服务提供者的期望。服务提供方在自己的测试集中，对这些“期望”进行校验。服务提供方在做出任何改变的时候，只要能保证满足消费者不对其产生影响即可。一旦对任何消费者产生影响，在正式发布前就可以知晓，而且只需要与那些会产生的影响的消费者进行协商即可。</p>

<p>这里的Contracts分为三部分<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>：</p>

<ol>
<li><p>提供者契约（Provider contracts）——提供者契约是我们最为熟悉的一种的服务契约，参考 WSDL+XML Schema+WS-Policy。顾名思义，提供者契约是以提供者为中心的。提供者规定了它要提供什么；然后，各消费者便将自己绑定到这个一成不变的契约上。不论消费者实际需要多少功能，消费者接受了提供者契约，就将自己与该提供者的全体功能耦合起来了。</p></li>
<li><p>消费者契约（Consumer contracts）——另一方面，消费者契约是对一个消费者的需求更为精确的描述。消费者契约描述了，在一次具体交互场合下，提供者功能中消费者需要的特定部分。消费者契约可被用来标注一个现有的提供者契约，另外消费者契约也有助于发现一个现今尚未规定的提供者契约。</p></li>
<li><p>消费者驱动的契约（Consumer-driven contracts）——消费者驱动的契约描述的是服务提供者向其所有当前消费者承诺遵守的约束。一旦各消费者把自己的具体期望告知提供者，消费者驱动的契约就被创建了。在提供者方面创建的约束，确定了一个消费者驱动的契约。若提供者接受了一个消费者驱动的契约，那么它只需保证已有约束仍能得到满足，即可自行改进与修改其服务。</p></li>
</ol>


<p>现在我们看看<a href="https://github.com/realestate-com-au/pact">Pact</a>和<a href="https://github.com/thoughtworks/pacto">Pacto</a>这两个测试框架是如何实现的。</p>

<h2>Pact</h2>

<p>Pact为服务消费者提供了API，用来定义消费者对服务提供方的http请求、以及期望的http响应。这些期望被用在消费者的spec测试中，来mock服务提供方。所有的交互都会被记录下，然后在服务提供方的spec测试中回放，来确保服务提供方确实提供了消费者所期望的响应。</p>

<p>这使得对于一个集成场景，契约的两方都可以快速、独立地进行单元测试。</p>

<p>工作原理<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> ：</p>

<p><img src="http://iamshijie.github.io/images/pact-step1.png" alt="pact-step1.png" /></p>

<p><img src="http://iamshijie.github.io/images/pact-step2.png" alt="pact-step2.png" /></p>

<p>Pact以gem的形式提供，gem地址：<a href="https://rubygems.org/gems/pact">https://rubygems.org/gems/pact</a></p>

<p>使用方法：<a href="https://github.com/realestate-com-au/pact#installation">https://github.com/realestate-com-au/pact#installation</a></p>

<p>一些最佳实践：<a href="https://github.com/realestate-com-au/pact/wiki/Best-practices">Pact-best-practices</a></p>

<p><a href="https://github.com/realestate-com-au/pact/tree/master/example">Example</a></p>

<h2>Pacto</h2>

<p>Pacto包含两部分，request clause和response clause。</p>

<p>Request clause定义了消费者发送给服务提供方的请求中必须包含的信息，这些信息将被用于一个渲染service。通常包含了http头、需要的参数、以及请求体（json形式）。</p>

<p>Response clause定义了服务提供方需要返回给消费者的信息，从而成功完成一次事务。通常包含请求头和请求体（json形式）。</p>

<p>通常通过产生、校验、服务打桩三部分。</p>

<p>使用方法：<a href="https://github.com/thoughtworks/pacto#usage">https://github.com/thoughtworks/pacto#usage</a>或者这里<a href="http://thoughtworks.github.io/pacto/usage/">http://thoughtworks.github.io/pacto/usage/</a></p>

<p><a href="https://github.com/thoughtworks/pacto/tree/master/sample_apis">Exmaple API</a></p>

<p><a href="https://github.com/thoughtworks/pacto/tree/master/samples">Sample APP</a></p>

<h2>区别：</h2>

<ol>
<li><p>Pacto仅支持json服务，原生支持Ruby，对于非Ruby项目，提供了<a href="https://github.com/thoughtworks/pacto#pacto-server-non-ruby-usage">Pacto Server</a>。</p>

<p> Pact支持Ruby, JVM(<a href="https://github.com/DiUS/pact-jvm">pact-jvm</a>), .net的消费者，Ruby mock server使用了Javascript进行包装。对于非ruby的服务提供方，Pact提供了<a href="https://github.com/bethesque/pact-provider-proxy">Pact Provider Proxy</a></p></li>
<li><p>Pacto不支持多状态码验证（如200、201）。Pact允许在服务提供者不同状态下，生成同样的请求，允许在同样的endpoint上测试不同的http响应码，或者在不同状态下测试相同的资源。</p></li>
<li><p>Pacto通过录制与现有服务的交互，可以录制契约。不用手工编写，使得契约非常容易创建。</p></li>
<li><p>Pacto一旦录制完成，契约就是静态的，既可以校验服务消费者，也可以校验服务提供方。</p>

<p> Pact的契约是动态生成的中间产物，更容易维护<a href="https://github.com/realestate-com-au/pact/wiki/FAQ#why-are-the-pacts-generated-and-not-static">why?</a>。</p></li>
<li><p>Pact支持正则表达匹配。</p></li>
<li><p>Pact有<a href="https://github.com/bethesque/pact_broker">Pact Broker</a>，提供了自动生成的文档、网络图，使得在产品环境和最新版本（消费者和提供者）间进行交叉测试成为可能，从而将消费者和提供者的发布循环解耦。</p></li>
</ol>


<p>总结：</p>

<ol>
<li><p>契约录制功能，使得当需要对一个现有第三方服务打桩的时候，Pacto成了更好的选择。在这种情况下，服务提供方状态的缺失、正则匹配可能无关紧要，因为你不可能在服务方创建一套数据，而不使用当前测试的接口。</p></li>
<li><p>对于服务提供方不还不存在的新项目来说，Pact可能更好，因为消费者的功能可以驱动出服务提供方的需求。</p></li>
</ol>


<p>参考资料：</p>

<ol>
<li><p><a href="http://www.slideshare.net/catosplace/lightening-talk-agile-auckland-pact-consumerdriven-contract-testing-integrated-tests-are-a-scam">Lightening Talk: Auckland Continuous Delivery Meetup [Sept 2014] - Pact: Consumer-Driven Contract Testing (Integrated Tests Are A Scam)</a></p></li>
<li><p><a href="http://techblog.realestate.com.au/testing-interactions-with-web-services-without-integration-tests-in-ruby/">realestate.com.au:http://techblog.realestate.com.au/testing-interactions-with-web-services-without-integration-tests-in-ruby/</a></p></li>
<li><p>微服务测试</p>

<p> <a href="http://martinfowler.com/articles/microservice-testing/#agenda"><img src="http://iamshijie.github.io/images/microservice-testing-summary.png" alt="microservice-testing-summary.png" /></a></p></li>
<li><p><a href="https://github.com/realestate-com-au/pact/wiki/FAQ#how-does-pact-differ-from-pacto">Pact and Pacto</a></p></li>
</ol>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>关于Microservices,参阅<a href="http://www.thoughtworks.com/radar/techniques/microservices">ThoughtWorks技术雷达</a>和<a href="http://martinfowler.com/articles/microservices.html">Martin Fowler的blog</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Martin Flower的<a href="http://martinfowler.com/articles/microservice-testing/#agenda">微服务测试</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>这三种契约的描述，摘自InfoQ的文章<a href="http://www.infoq.com/cn/articles/consumer-driven-contracts">用消费者驱动的契约进行面向服务开发</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>这两张图片来自<a href="http://dius.com.au/2014/05/19/simplifying-micro-service-testing-with-pacts/">Simplifying Micro-Service testing with Pacts</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用octopress创建个人博客]]></title>
    <link href="http://iamshijie.github.io/blog/2015/01/21/how-to-setup-blog-with-octopress/"/>
    <updated>2015-01-21T10:02:40+08:00</updated>
    <id>http://iamshijie.github.io/blog/2015/01/21/how-to-setup-blog-with-octopress</id>
    <content type="html"><![CDATA[<p>Refer to <a href="http://octopress.org/docs/setup">this link</a></p>

<p>开始之前的准备工作：安装Git、ruby、bundler。</p>

<h3>准备</h3>

<ol>
<li><p>下载octopress: <code>git clone git://github.com/imathis/octopress.git octopress</code></p></li>
<li><p>进入octopress目录，执行<code>rake install</code></p></li>
</ol>


<h3>创建部署</h3>

<ol>
<li><p>创建一个新的Github的空repo，并且命名为iamshijie.github.io</p></li>
<li><p>进入自己下载的octopress的目录并执行<code>rake setup_github_pages</code>。当提示输入repo地址时，输入上一步创建的git地址：<code>git@github.com:Shi-Jie/iamshijie.github.io.git</code></p></li>
<li><p>继续在octopress目录下执行<code>rake generate </code>。此时，打开<a href="http://iamshijie.github.io.git">http://iamshijie.github.io.git</a>就能看到blog原型。再执行<code>rake deploy</code></p></li>
<li><p>git提交。本别执行<code>git add .</code> 、<code>git commit -m 'your message'</code>、<code>git push origin source</code></p></li>
<li><p>修改个人blog的默认分支为source，而非master <a href="https://github.com/iamshijie/iamshijie.github.io/settings">git link</a></p></li>
</ol>


<h3>创建博客</h3>

<p>这部分可以参考之前在QA community的<a href="http://thoughtworks-china-qa.github.io/blog/2015/01/13/how-to-post-to-this-blog/">blog</a>。</p>

<ol>
<li><p>clone博客repo到本地：<code>git clone git@github.com:iamshijie/iamshijie.github.io.git</code></p>

<p> <strong>确保你的默认分支是source。即<code>git status</code>后看到的是</strong></p>

<pre><code class="`"> Shi-Jie:iamshijie.github.io shijie$ git status
 On branch source
 Your branch is up-to-date with 'origin/source'.
 nothing to commit, working directory clean
</code></pre></li>
<li><p>本地生成发布目录，执行<code>rake setup_github_pages</code>交互时输入<code>git@github.com:Shi-Jie/iamshijie.github.io.git</code></p></li>
<li><p>执行<code>rake install</code>。安装默认主题。</p></li>
<li><p>创建新post。在repo下执行<code>rake new_post["How to create blog with octopress"]</code></p></li>
<li><p>修改上一步生成的markdown文件，直接在默认生成的内容后进行添加编辑：</p>

<pre><code class="`"> ---
 layout: post
 title: "How to setup blog with octopress"
 date: 2015-01-21 09:16:24 +0800
 comments: true
 categories:
 ---
</code></pre></li>
<li><p>使用<code>rake preview</code>进行预览</p></li>
<li><p>确认无误后。使用<code>rake gen_deploy</code>发布的master。完成后，就可以在个人<a href="http://iamshijie.github.io">http://iamshijie.github.io</a>看到效果</p></li>
<li><p>将改动提交到source分支</p>

<pre><code class="`"> git add .
 git commit -m 'Post my first blog. - ShiJie'
 git push
</code></pre></li>
</ol>

]]></content>
  </entry>
  
</feed>
